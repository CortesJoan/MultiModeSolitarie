File: Card.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class Card : MonoBehaviour, IPointerClickHandler
{
    [SerializeField] CardType cardType;
    [SerializeField] CardNumber cardNumber;

    public UnityEvent<CardType> onCardTypeChanged;
    public UnityEvent onCardHided;
    public UnityEvent onCardShowed;
    public UnityEvent onPriorityDecreased;
    public UnityEvent onCardSelected;
    public UnityEvent<CardNumber> onCardNumberChanged;
    [SerializeField] private bool cardIsSelectable=true;
    // Start is called before the first frame update
    void Start()
    {
    }

    // Update is called once per frame
    void Update()
    {
    }

    public void Show()
    {
        onCardShowed?.Invoke();
    }

    public void Hide()
    {
        onCardHided?.Invoke();
    }

    public void DecreasePriority()
    {
        onPriorityDecreased?.Invoke();
    }

    public CardType GetCardType()
    {
        return cardType;
    }

    public void SetCardType(CardType newCardType)
    {
        cardType = newCardType;
        onCardTypeChanged?.Invoke(newCardType);
    }

    public CardNumber GetCardNumber()
    {
        return cardNumber;
    }

    public void SetCardNumber(CardNumber newCardNumber)
    {
        cardNumber = newCardNumber;
        onCardNumberChanged?.Invoke(newCardNumber);
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        onCardSelected.Invoke();
        Debug.Log("Card selected");
    }

    public void ToggleSelectable(bool isSelectable)
    {
        cardIsSelectable = isSelectable;
        
    }
}

public enum CardNumber
{
    Joker,
    Ace,
    Number2,
    Number3,
    Number4,
    Number5,
    Number6,
    Number7,
    Number8,
    Number9,
    Number10,
    Jack,
    Queen,
    King
}

public enum CardType
{
    Hearts,
    Tiles,
    Clover,
    Pikes
} 
File: CardIsCardType.cs 
﻿using UnityEngine;

namespace DefaultNamespace
{
    [CreateAssetMenu(fileName = "new CardIsCardType", menuName = "CardIsCardType", order = 100)]
    public class CardIsCardType :SlotConditions
    {
        [SerializeField] CardType cardType;
            
        public override bool IsConditionMet()
        {               
            return  cardToCheck.GetCardType() == cardType;
        }
    }
} 
File: CardNumberCondition.cs 
﻿using System;
using UnityEngine;

[CreateAssetMenu(fileName = "new CardNumberCondition", menuName = "CardNumberCondition", order = 100)]

public class CardNumberCondition : SlotConditions
{
    [SerializeField] private CardNumber neededCardNumber;
    [SerializeField] private NumberCondition numberCondition;

    public override bool IsConditionMet()
    {
        return CheckNumberCondition();
    }

    bool CheckNumberCondition()
    {
        bool isConditionMet;
        switch (numberCondition)
        {
            case NumberCondition.Increase:

                isConditionMet = cardToCheck.GetCardNumber() > neededCardNumber;
                if (isConditionMet)
                {
                    neededCardNumber++;
                }
                break;
            case NumberCondition.Decrease:
                isConditionMet = cardToCheck.GetCardNumber() < neededCardNumber;

                if (isConditionMet)
                {
                    neededCardNumber--;
                }
                break;
            case NumberCondition.Equals:
                isConditionMet = cardToCheck.GetCardNumber() == neededCardNumber;
                break;
            case NumberCondition.NotEquals:
                isConditionMet = cardToCheck.GetCardNumber() != neededCardNumber;
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
        return isConditionMet;
    }

    enum NumberCondition
    {
        Increase,
        Decrease,
        Equals,
        NotEquals
    }
} 
File: CardSelectionManager.cs 
using UnityEngine;
using UnityEngine.InputSystem;

public class CardSelectionManager : MonoBehaviour
{
    [SerializeField] private PlayerInput playerInput;
    private Camera mainCamera;
    private Card selectedCard;
    private Vector3 offset;
    private bool dragging;
  [SerializeField]  private PlayerCardManager playerCardManager;
    private void Awake()
    {
        mainCamera = Camera.main;
    }

    private void OnEnable()
    {
        if (playerInput != null)
        {
            playerInput.onActionTriggered += HandleInput;
        }
    }

    private void OnDisable()
    {
        if (playerInput != null)
        {
            playerInput.onActionTriggered -= HandleInput;
        }
    }

    private void HandleInput(InputAction.CallbackContext context)
    {
        if (context.action.name == "MousePosition")
        {
            OnMousePositionChanged(context);
        }
        else if (context.action.name == "ArrowKeys")
        {
            OnArrowKeysChanged(context);
        }
        else if (context.action.name == "CardSelected")
        {
            OnCardSelected(context);
        }
    }

    private void OnMousePositionChanged(InputAction.CallbackContext context)
    {
        if (!dragging || selectedCard == null) return;

        Vector2 mousePosition = context.ReadValue<Vector2>();
        Vector3 worldMousePosition = mainCamera.ScreenToWorldPoint(new Vector3(mousePosition.x, mousePosition.y, -mainCamera.transform.position.z));
        selectedCard.transform.position = new Vector3(worldMousePosition.x + offset.x, worldMousePosition.y + offset.y, selectedCard.transform.position.z);
    }

    private void OnArrowKeysChanged(InputAction.CallbackContext context)
    {
        if (dragging || selectedCard == null) return;

        Vector2 arrowKeys = context.ReadValue<Vector2>();
        // Implement logic for moving the selected card to the next available position using arrow keys
    }

    private void OnCardSelected(InputAction.CallbackContext context)
    {
        if (context.started)
        {
            RaycastHit2D hit = Physics2D.Raycast(mainCamera.ScreenToWorldPoint(Input.mousePosition), Vector2.zero);
            if (hit.collider != null)
            {
                Card card = hit.collider.GetComponentInParent<Card>();
                if (card != null)
                {
                    dragging = true;
                    selectedCard = card;
                    playerCardManager.SelectCard(card); // Call the SelectCard method from PlayerCardManager

                    Vector3 cardPosition = card.transform.position;
                    Vector2 mousePosition = context.ReadValue<Vector2>();
                    Vector3 mouseWorldPosition = mainCamera.ScreenToWorldPoint(new Vector3(mousePosition.x, mousePosition.y, -mainCamera.transform.position.z));
                    offset = cardPosition - new Vector3(mouseWorldPosition.x, mouseWorldPosition.y, cardPosition.z);
                }
            }
        }
        else if (context.canceled)
        {
            dragging = false;
            selectedCard = null;
            playerCardManager.UnSelectCard(selectedCard); // Call the UnSelectCard method from PlayerCardManager

        }
    }
} 
File: CardVisualUpdater.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CardVisualUpdater : MonoBehaviour
{
    [SerializeField] List<Sprite> availableVisuals;
    [SerializeField] Card relatedCard;
    [SerializeField] SpriteRenderer spriteRenderer;
    [SerializeField] VisualDataBank visualDataBank;
    [SerializeField] Sprite hideSprite;

    [SerializeField] Sprite lastShowedCard;

    public void OnCardTypeChanged(CardType newCardType)
    {
        Debug.Log("Card changed to " + newCardType);
        Sprite newCardSprite = VisualDataBank.instance.GetCardVisual(newCardType, relatedCard.GetCardNumber());
        UpdateCardSprite(newCardSprite);
    }

    public void OnCardNumberChanged(CardNumber newCardNumber)
    {
        Sprite newCardSprite = VisualDataBank.instance.GetCardVisual(relatedCard.GetCardType(), newCardNumber);
        UpdateCardSprite(newCardSprite);
    }

    void UpdateCardSprite(Sprite newSprite)
    {
        spriteRenderer.sprite = newSprite;
        lastShowedCard = newSprite;
    }

    public void OnHideCard()
    {
        spriteRenderer.sprite = hideSprite;
    }

    public void OnShowCard()
    {
        spriteRenderer.sprite = lastShowedCard;
        spriteRenderer.sortingOrder = 1;
    }

    public void OnPriorityDecreased()
    {
        spriteRenderer.sortingOrder--;
    }

    public void OnCardSelected()
    {
        spriteRenderer.color = Color.yellow;
        
    }
} 
File: Condition.cs 
using UnityEngine;

public abstract class Condition :ScriptableObject
{
    public abstract bool IsConditionMet();
}

public interface ICondicionable
{
}
 
File: GameRules.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
[CreateAssetMenu(fileName = "new GameRules", menuName = "GAMERULES", order = 100)]

public class GameRules : ScriptableObject
{
    [SerializeField] int maxHoldingCardsNumber;
    [SerializeField] int cardsToPutInLayout;
    [SerializeField] int totalCards;

    public int TotalCards { get => totalCards; set => totalCards = value; }
}
 
File: PileOfCards.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

public class PileOfCards : MonoBehaviour, IPointerDownHandler , IPointerClickHandler
{
    [SerializeField] List<Card> currentPileOfCards;
    int currentShowingCard = -1;
    [SerializeField] private Transform showedPileSlot;

    public void SetPileOfCards(List<Card> newPileOfCards)
    {
        currentPileOfCards = newPileOfCards;
    }

    public List<Card> GetPileOfCards()
    {
        return currentPileOfCards;
    }

    public void ShowNextCard()
    {
        if ((currentShowingCard+1) >= currentPileOfCards.Count)
        {
            ClosePileOfCards();
        }
        else
        {
            if (currentShowingCard!=-1)
            {
                currentPileOfCards[currentShowingCard].DecreasePriority();
            }
            currentShowingCard++;
            Debug.Log("Showing card" +currentShowingCard);
            var currnetCard = currentPileOfCards[currentShowingCard];
            
            
            currnetCard.Show();
            currnetCard.transform.parent = showedPileSlot.transform;
            currnetCard.transform.localPosition = Vector3.zero;
        }
    }

    public void ClosePileOfCards()
    {
        currentShowingCard = -1;
        foreach (var card in currentPileOfCards)
        {
            card.transform.parent = transform;
            card.transform.localPosition = Vector3.zero;
            card.Hide();
        }
    }

    public void OnPointerDown(PointerEventData eventData)
    {
         Debug.Log("pointerdownpileofcards");
    }

    public void OnPointerClick(PointerEventData eventData)
    {
 
        ShowNextCard();
        Debug.Log("Showed next card");
        
    }
} 
File: PlayerCardManager.cs 
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class PlayerCardManager : MonoBehaviour  
{
    List<Card> selectedCards = new List<Card>();
    public UnityEvent<Card>  onCardSelected = new UnityEvent<Card> ();
    public UnityEvent<Card> onCardUnSelected = new UnityEvent<Card> ();
    
    public void SelectCard(Card card)
    {
        selectedCards.Add(card);
        onCardSelected?.Invoke(card);
    }
    
    public void UnSelectCard(Card card)
    {
        selectedCards.Remove(card);
        onCardUnSelected?.Invoke(card);
    }

    public List<Card> GetSelectedCards()
    {
        return selectedCards;
    }

   
}
 
File: PlayerCardManagerVisuals.cs 
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.InputSystem;

public class PlayerCardManagerVisuals : MonoBehaviour
{
    [SerializeField] PlayerCardManager playerCardManager;
    private Vector2 pointerPosition = new Vector2();
    List<Card> currentSelectedCards =  new List<Card>();    
    private void OnEnable()
    {
        playerCardManager.onCardSelected.AddListener( OnCardSelected);
        playerCardManager.onCardUnSelected.AddListener(OnCardUnSelected);
    }

    private void Update()
    {
        if (currentSelectedCards.Count>0)
        {
            currentSelectedCards.First().transform.position = Camera.main.ScreenToWorldPoint(pointerPosition);
        }
    }

    public void OnCardSelected(Card selectedCard)
    {
        currentSelectedCards= playerCardManager.GetSelectedCards();
        selectedCard.transform.parent = currentSelectedCards.Last().transform;
        selectedCard.transform.localPosition = new Vector2(0, selectedCard.transform.localPosition.y + 1);
    }

    public void OnCardUnSelected(Card unSelectedCard)
    {        
        currentSelectedCards= playerCardManager.GetSelectedCards();

    }

    public void UpdatePointerPosition(InputValue value)
    {
        pointerPosition=  value.Get<Vector2>();
    }
} 
File: SlotCardAttacher.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SlotCardAttacher : MonoBehaviour
{
    List<Card> attachedCards = new List<Card>();
    [SerializeField] private List<SlotConditions> slotConditions = new List<SlotConditions>();

    void Start()
    {
    }

    // Update is called once per frame
    void Update()
    {
    }

    public void AttachCard(Card card)
    {
        if (slotConditions.TrueForAll(a=>a.IsConditionMet()))
        {
            
        }
        attachedCards.Add(card);
    }

    public void DeAttachCard(Card card)
    {
        attachedCards.Remove(card);
    }
}

public class SlotConditions : Condition
{
    protected Card cardToCheck;
    public override bool IsConditionMet()
    {
        return true;
    }

    public void SetCardCondition(Card card)
    {
        cardToCheck = card;
    }
} 
File: SolitaireLayout.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SolitaireLayout : MonoBehaviour
{
    [SerializeField] int rows = 7;
    [SerializeField] int spaceBetweenRows = 2;
    [SerializeField] GameObject emptySlotPrefab;
    [SerializeField] List<GameObject> layoutInstantiatedSlots;
    [SerializeField] float cardYSeparation = 1;

    [ContextMenu(nameof(PrepareLayout))]
    void PrepareLayout()
    {
        foreach (var slot in layoutInstantiatedSlots)
        {
            DestroyImmediate(slot.gameObject);
        }
        layoutInstantiatedSlots.Clear();
        int recorredSpace = 0;
        for (int i = 0; i < rows; i++)
        {
            GameObject instantiatedEmptySlot = Instantiate(emptySlotPrefab, this.transform);
            instantiatedEmptySlot.transform.localPosition = new Vector3(recorredSpace, 0, 0);

            layoutInstantiatedSlots.Add(instantiatedEmptySlot);

            recorredSpace += spaceBetweenRows;
        }
    }

    public void PutCardsInLayout(List<List<Card>> cards)
    {
        Debug.Log($"cards count {cards.Count}  ");

        for (int i = 0; i < layoutInstantiatedSlots.Count; i++)
        {
            GameObject layout = layoutInstantiatedSlots[i];
            float currentSeparation = 0;
            foreach (Card card in cards[i])
            {
                card.transform.SetParent(layout.transform);
                card.transform.localPosition = Vector3.down * currentSeparation;
                currentSeparation += cardYSeparation;
            }
        }


    }
    public int GetRows()
    {
        return rows;
    }
}
 
File: SolitarieCardGenerator.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SolitarieCardGenerator : MonoBehaviour, IGameGenerator
{
    [SerializeField] Card cardTemplatePrefab;
    [SerializeField] SolitaireLayout cardLayout;
    [SerializeField] PileOfCards pileOfCards;
    [SerializeField] GameRules gameRules;

    [ContextMenu(nameof(GenerateGame))]
    public void GenerateGame()
    {
        DestroyPreciousPileOfCards();
        if (VisualDataBank.instance == null)
        {
            VisualDataBank.instance = FindObjectOfType<VisualDataBank>();
        }
        List<List<Card>> generatedCards = new List<List<Card>>();
        int remainingCards = gameRules.TotalCards;
        existingCards.Clear();
        int rows = cardLayout.GetRows();
        int cardsPerRow = 1;
        for (int i = 0; i < rows; i++)
        {
            List<Card> currentRowCards = new List<Card>();
            FillVoidCards(ref currentRowCards, cardsPerRow);
            cardsPerRow++;
            generatedCards.Add(currentRowCards);
            currentRowCards.ForEach((c) => c.Hide());
            remainingCards -= cardsPerRow;
        }

        cardLayout.PutCardsInLayout(generatedCards);

        List<Card> cardsToAddToThePile = new List<Card>();
        FillVoidCards(ref cardsToAddToThePile, remainingCards);
        pileOfCards.SetPileOfCards(cardsToAddToThePile);
        foreach (var card in cardsToAddToThePile)
        {
            card.transform.parent = pileOfCards.transform;
            card.transform.localPosition = Vector3.zero;
            card.Hide();
        }
    }

    public Card InstantiateEmptyCard()
    {
        return Instantiate<Card>(cardTemplatePrefab);
    }

    HashSet<string> existingCards = new HashSet<string>();

    public void FillVoidCards(ref List<Card> cards, int amount)
    {
        // Create a list of all possible card types and numbers

        List<CardType> types = new List<CardType>()
            { CardType.Hearts, CardType.Tiles, CardType.Clover, CardType.Pikes };
        List<CardNumber> numbers = new List<CardNumber>()
        {
            CardNumber.Ace, CardNumber.Number2, CardNumber.Number3, CardNumber.Number4, CardNumber.Number5,
            CardNumber.Number6, CardNumber.Number7, CardNumber.Number8, CardNumber.Number9, CardNumber.Number10,
            CardNumber.Jack, CardNumber.Queen, CardNumber.King
        };


        foreach (Card card in cards)
        {
            existingCards.Add(card.GetCardType().ToString() + card.GetCardNumber().ToString());
        }

        // Loop through the list and fill the void cards with random cards that are not already in the list
        for (int i = 0; i < amount; i++)
        {
            // Pick a random card type and number
            CardType randomType = types[Random.Range(0, types.Count)];
            CardNumber randomNumber = numbers[Random.Range(1, numbers.Count)];

            // Check if the card already exists in the list
            string cardKey = randomType.ToString() + randomNumber.ToString();
            while (existingCards.Contains(cardKey))
            {
                // If it does, pick another random card
                randomType = types[Random.Range(0, types.Count)];
                randomNumber = numbers[Random.Range(0, numbers.Count)];
                cardKey = randomType.ToString() + randomNumber.ToString();
            }

            // Create a new card with the random type and number and add it to the list
            Card newCard = InstantiateEmptyCard();
            newCard.SetCardType(randomType);
            newCard.SetCardNumber(randomNumber);
            cards.Add(newCard);

            // Add the card to the hash set
            existingCards.Add(cardKey);
        }
    }

    public void DestroyPreciousPileOfCards()
    {
        var pileOfCardsCards = pileOfCards.GetPileOfCards();
        for (var i = 0; i < pileOfCardsCards.Count; i++)
        {
            var cards = pileOfCardsCards[i];
#if UNITY_EDITOR
            DestroyImmediate(cards.gameObject);
#else
            Destroy(cards.gameObject);
#endif
        }
        pileOfCardsCards.Clear();
    }
}

public interface IGameGenerator
{
    void GenerateGame();
} 
File: VisualDataBank.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class VisualDataBank : MonoBehaviour
{

    [SerializeField] List<CardTypeNumber> cardSprites;
    public static VisualDataBank instance;
    /*{

        get
        {
            if (instance == null)
                instance = FindObjectOfType<VisualDataBank>();
            return instance;
        }
        set 
        {
            instance = value;
        }
    }*/
    public void Awake()
    {
        if (instance == null)
        {
            instance = this;
        }
        else
        {
            Destroy(this.gameObject);
        }
    }

    public Sprite GetCardVisual(CardType cardType, CardNumber cardNumber)
    {
        return cardSprites[(int)cardType].spriteNumber[(int)cardNumber];
    }
    [System.Serializable]
    class CardTypeNumber
    {
        public List<Sprite> spriteNumber;

    }
}
 
File: VisualDataBankEditor.cs 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
[CustomEditor(typeof(VisualDataBank))]
public class VisualDataBankEditor : Editor
{
    private void OnEnable()
    {
        VisualDataBank visualDataBank = (VisualDataBank)target;
        visualDataBank.Awake();
    }
}
 
